// SpaceInvaders.c
// Runs on LM4F120/TM4C123
// Jonathan Valvano and Daniel Valvano
// This is a starter project for the edX Lab 15
// In order for other students to play your game
// 1) You must leave the hardware configuration as defined
// 2) You must not add/remove any files from the project
// 3) You must add your code only this this C file
// I.e., if you wish to use code from sprite.c or sound.c, move that code in this file
// 4) It must compile with the 32k limit of the free Keil

// April 10, 2014
// http://www.spaceinvaders.de/
// sounds at http://www.classicgaming.cc/classics/spaceinvaders/sounds.php
// http://www.classicgaming.cc/classics/spaceinvaders/playguide.php
/* This example accompanies the books
   "Embedded Systems: Real Time Interfacing to Arm Cortex M Microcontrollers",
   ISBN: 978-1463590154, Jonathan Valvano, copyright (c) 2013

   "Embedded Systems: Introduction to Arm Cortex M Microcontrollers",
   ISBN: 978-1469998749, Jonathan Valvano, copyright (c) 2013

 Copyright 2014 by Jonathan W. Valvano, valvano@mail.utexas.edu
    You may use, edit, run or distribute this file
    as long as the above copyright notice remains
 THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 VALVANO SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL,
 OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 For more information about my classes, my research, and my books, see
 http://users.ece.utexas.edu/~valvano/
 */
// ******* Required Hardware I/O connections*******************
// Slide pot pin 1 connected to ground
// Slide pot pin 2 connected to PE2/AIN1
// Slide pot pin 3 connected to +3.3V 
// fire button connected to PE0
// special weapon fire button connected to PE1
// 8*R resistor DAC bit 0 on PB0 (least significant bit)
// 4*R resistor DAC bit 1 on PB1
// 2*R resistor DAC bit 2 on PB2
// 1*R resistor DAC bit 3 on PB3 (most significant bit)
// LED on PB4
// LED on PB5

// Blue Nokia 5110
// ---------------
// Signal        (Nokia 5110) LaunchPad pin
// Reset         (RST, pin 1) connected to PA7
// SSI0Fss       (CE,  pin 2) connected to PA3
// Data/Command  (DC,  pin 3) connected to PA6
// SSI0Tx        (Din, pin 4) connected to PA5
// SSI0Clk       (Clk, pin 5) connected to PA2
// 3.3V          (Vcc, pin 6) power
// back light    (BL,  pin 7) not connected, consists of 4 white LEDs which draw ~80mA total
// Ground        (Gnd, pin 8) ground

// Red SparkFun Nokia 5110 (LCD-10168)
// -----------------------------------
// Signal        (Nokia 5110) LaunchPad pin
// 3.3V          (VCC, pin 1) power
// Ground        (GND, pin 2) ground
// SSI0Fss       (SCE, pin 3) connected to PA3
// Reset         (RST, pin 4) connected to PA7
// Data/Command  (D/C, pin 5) connected to PA6
// SSI0Tx        (DN,  pin 6) connected to PA5
// SSI0Clk       (SCLK, pin 7) connected to PA2
// back light    (LED, pin 8) not connected, consists of 4 white LEDs which draw ~80mA total

#include "..//tm4c123gh6pm.h"
#include "Nokia5110.h"
#include "Random.h"
#include "TExaS.h"
#include "Sound.h"

void DisableInterrupts(void);	  // Disable interrupts
void EnableInterrupts(void);  	// Enable interrupts
void missLEDOn(void); 					// turn on missile activated light
void missLEDOff(void);					// signals now able to launch another missile
void lasLEDOn(void); 					// turn on laser activated light
void lasLEDOff(void);					// signals now able to launch another laser
unsigned long TimerCount;
unsigned long ADCdata;    			// 12-bit 0 to 4095 sample
unsigned long Semaphore2A = 0;
unsigned long playerFlag = 0;		// signals whether the player has moved their ship
unsigned long laserFlag = 0;
unsigned long missileFlag = 0;
unsigned long FrameCount = 0;		// switching FrameCount between 0 and 1 allows for image to be animated
//const int SineWave[64] = 				// sine wave ranging for 0 to 15 with 256 samples
//{8,8,9,10,10,11,12,12,13,13,14,14,14,15,15,15,15,15,15,15,14,14,14,13,13,12,11,11,10,9,
//9,8,7,6,6,5,4,4,3,2,2,1,1,1,0,0,0,0,0,0,0,1,1,1,2,2,3,3,4,5,5,6,7,8};
const int ExplosionSound[1];
const int MissileSound[1];	
const int LaserSound[1];
const int DamageSound[1];
unsigned int playerPosition;		// updated with the x-position of the player's ship during Systick interrupt (30 Hz)
unsigned int randomnum;					// used to randomize enemy projectiles	
unsigned int currentLevel;
unsigned int numEnemies = 8;
unsigned int playMissile = 8;
unsigned int playLaser = 8;
signed int enemyDir = 1;		// initialize the enemy directions as positive (enemies move right)
unsigned int enemyDrop = 0;


// *************************** Images ***************************
// enemy ship that starts at the top of the screen (arms/mouth closed)
// width=16 x height=10
const unsigned char SmallEnemy30PointA[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x0F, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts at the top of the screen (arms/mouth open)
// width=16 x height=10
const unsigned char SmallEnemy30PointB[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0x0F, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x0F, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts in the middle of the screen (arms together)
// width=16 x height=10
const unsigned char SmallEnemy20PointA[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts in the middle of the screen (arms apart)
// width=16 x height=10
const unsigned char SmallEnemy20PointB[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0,
 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts at the bottom of the screen (arms down)
// width=16 x height=10
const unsigned char SmallEnemy10PointA[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F,
 0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// enemy ship that starts at the bottom of the screen (arms up)
// width=16 x height=10
const unsigned char SmallEnemy10PointB[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0xFF, 0xFF, 0x0F, 0xFF, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// image of the player's ship
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=18 x height=8
const unsigned char PlayerShip0[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA,
 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small, fast bonus enemy that occasionally speeds across the top of the screen after enough enemies have been killed to make room for it
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=20 x height=7
const unsigned char SmallEnemyBonus0[] = {
 0x42, 0x4D, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0xFF, 0x0F, 0xF0,
 0xFF, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small shield floating in space to cover the player's ship from enemy fire (undamaged)
// width=18 x height=5
const unsigned char Bunker0[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0x00,
 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small shield floating in space to cover the player's ship from enemy fire (moderate generic damage)
// width=18 x height=5
const unsigned char Bunker1[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0x00,
 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xA0, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0xA0, 0xA0, 0xAA,
 0xAA, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA0, 0x00, 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small shield floating in space to cover the player's ship from enemy fire (heavy generic damage)
// width=18 x height=5
const unsigned char Bunker2[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xAA, 0x00,
 0x00, 0x00, 0xAA, 0x0A, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0xA0, 0xAA, 0xA0, 0xA0, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x0A, 0x00, 0xA0, 0xA0,
 0xA0, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space used to cover a bunker that is destroyed
// width=18 x height=5
const unsigned char Bunker3[] = {
 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// large explosion that can be used upon the demise of the player's ship (first frame)
// width=18 x height=8
const unsigned char BigExplosion0[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x90, 0x00, 0x90, 0xB0, 0x0A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xA0, 0x00, 0xE0, 0x00, 0x00,
 0x90, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
 0x00, 0xE0, 0x0A, 0x0A, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xFF};

// large explosion that can be used upon the demise of the player's ship (second frame)
// width=18 x height=8
const unsigned char BigExplosion1[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x09, 0x00, 0xB0, 0x00, 0xA0, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x90,
 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x0A, 0x00, 0x90, 0x00, 0xB0, 0x00, 0x09, 0x00, 0x00, 0x00, 0xFF};

// small explosion best used for the demise of an enemy
// width=16 x height=10
const unsigned char SmallExplosion0[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,
 0x0F, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space following the small explosion for the demise of an enemy
// width=16 x height=10
const unsigned char SmallExplosion1[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// a missile in flight
// includes one blacked out row on the top, bottom, and right of the image to prevent smearing when moved 1 pixel down, up, or left
// width=4 x height=9
const unsigned char Missile0[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00,
 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// a missile in flight
// includes one blacked out row on the top, bottom, and left of the image to prevent smearing when moved 1 pixel down, up, or right
// width=4 x height=9
const unsigned char Missile1[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F,
 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space to cover a missile after it hits something
// width=4 x height=9
const unsigned char Missile2[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// a laser burst in flight
// includes one blacked out row on the top and bottom of the image to prevent smearing when moved 1 pixel up or down
// width=2 x height=9
const unsigned char Laser0[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 0x00,
 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space to cover a laser after it hits something
// width=2 x height=9
const unsigned char Laser1[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// *************************** Capture image dimensions out of BMP**********
#define BUNKERW     ((unsigned char)Bunker0[18])
#define BUNKERH     ((unsigned char)Bunker0[22])
#define ENEMY30W    ((unsigned char)SmallEnemy30PointA[18])
#define ENEMY30H    ((unsigned char)SmallEnemy30PointA[22])
#define ENEMY20W    ((unsigned char)SmallEnemy20PointA[18])
#define ENEMY20H    ((unsigned char)SmallEnemy20PointA[22])
#define ENEMY10W    ((unsigned char)SmallEnemy10PointA[18])
#define ENEMY10H    ((unsigned char)SmallEnemy10PointA[22])
#define ENEMYBONUSW ((unsigned char)SmallEnemyBonus0[18])
#define ENEMYBONUSH ((unsigned char)SmallEnemyBonus0[22])
#define LASERW      ((unsigned char)Laser0[18])
#define LASERH      ((unsigned char)Laser0[22])
#define MISSILEW    ((unsigned char)Missile0[18])
#define MISSILEH    ((unsigned char)Missile0[22])
#define PLAYERW     ((unsigned char)PlayerShip0[18])
#define PLAYERH     ((unsigned char)PlayerShip0[22])

// Used to define all objects in the game
struct State {
  unsigned long x;      						// x coordinate
	unsigned long maxpoint[2]; 					// range of x and y values
  unsigned long y;      						// y coordinate
  const unsigned char *image[4]; 		// ptr->image
  long life;            						// 0=dead, 1=alive
	unsigned long deathCounter;				// number of cycles to show the explosion BMP image
};          
typedef struct State STyp;
STyp Enemy[8];					// 4 enemies
STyp Bunker;
STyp Player;
STyp Missile[9];				// 5 missiles -  4 enemy missiles and 1 player missile
STyp Laser[9];					// 5 lasers -  4 enemy lasers and 1 player laser
STyp UFO;

void UFO_Init(void) {
	UFO.x = 0;			// 
	UFO.y = 10;	// 
	UFO.maxpoint[0] = UFO.x + ENEMYBONUSW;
	UFO.maxpoint[1] = UFO.y + ENEMYBONUSH;
	UFO.image[0] = SmallEnemyBonus0;	// no damage
	UFO.image[1] = SmallExplosion0;	// explosion
	UFO.life = 1;
	UFO.deathCounter = 3;
	Sound_Highpitch();
}

void UFO_Move(void) {
	if(UFO.life > 0 && UFO.x < 82) {
		UFO.x += 3;
		UFO.maxpoint[0] += 3;
	} else {
		UFO.life = 0;
	}
}

// **************Top_Enemy_Init*********************
// Initialize all enemies.  The maxpoint is used to define the range
// of x and y values that the enemy occupies.
// Input: none
// Output: none
void Enemy_Init(void){ int i;
  for(i=0;i<numEnemies;i++){
    Enemy[i].x = 15*(i%4);														// enemies separated by 15 pixels in x direction
		if(i < 4) {
			Enemy[i].y = 10;			// first row of enemies
			Enemy[i].maxpoint[0] = Enemy[i].x + ENEMY30W;		// max x-coordinate the enemy currently occupies
			Enemy[i].maxpoint[1] = Enemy[i].y + ENEMY30H;		// max y-coordinate the enemy currently occupies
			// enemy image alternates to allow for animation
			Enemy[i].image[0] = SmallEnemy30PointA;
			Enemy[i].image[1] = SmallEnemy30PointB;
		} else if(i >=4 || i < 8) {
			Enemy[i].y = 10 + ENEMY30H;					// second row of enemies												
			Enemy[i].maxpoint[0] = Enemy[i].x + ENEMY10W;		// max x-coordinate the enemy currently occupies
			Enemy[i].maxpoint[1] = Enemy[i].y + ENEMY10H;		// max y-coordinate the enemy currently occupies
			// enemy image alternates to allow for animation
			Enemy[i].image[0] = SmallEnemy10PointA;
			Enemy[i].image[1] = SmallEnemy10PointB;
		} else {
			Enemy[i].y = 10 + ENEMY30H + ENEMY20H;		// third row of enemies													
			Enemy[i].maxpoint[0] = Enemy[i].x + ENEMY20W;		// max x-coordinate the enemy currently occupies
			Enemy[i].maxpoint[1] = Enemy[i].y + ENEMY20H;		// max y-coordinate the enemy currently occupies
			// enemy image alternates to allow for animation
			Enemy[i].image[0] = SmallEnemy20PointA;
			Enemy[i].image[1] = SmallEnemy20PointB;
		}
    Enemy[i].life = 1;
		Enemy[i].deathCounter = 3;										// counts down time to display explosion before displaying blank space
   }
}

// **************Enemy_Move*********************
// Move the enemies back and forth in the x-direction. If an enemy
// reaches the edge of the screen (width = 84 pixels), the direction 
// of movement is reversed.  A positive enemyDir causes an enemy to move 
// right and a negative enemyDir moves them left.  If the direction is 
// reversed, the enemies move down.
// Input: none
// Output: none
void Enemy_Move(void){ 
	int i;
	int minY = 48;
	for(i=0;i<numEnemies;i++) {
			Enemy[i].x += enemyDir; 		// move the enemy along x-direction
			Enemy[i].maxpoint[0] += enemyDir; // move the enemy maxpoint along x-direction
			Enemy[i].y += enemyDrop;		// move the enemy down 
			Enemy[i].maxpoint[1] += enemyDrop;   // move the enmy maxpoint down 
			if(Enemy[i].y < minY) {
				minY = Enemy[i].y;
			}
	}
	enemyDrop = 0;
  for(i=0;i<numEnemies;i++){
		if(Enemy[i].life > 0) {
			if(Enemy[i].maxpoint[0] >= 82) {
				enemyDir = (-1)*currentLevel;		// reverse enemy direction (move left)
				enemyDrop = 2;		// drop all enemies down by 1 pixel
			}
			if(Enemy[i].x <= 0) {
				enemyDir = 1*currentLevel;			// reverse enemy direction (move right)
				enemyDrop = 2;		// drop all enemies down by 1 pixel
			}
		}
	}
	if(minY > 20 && UFO.life <= 0 && randomnum > 8 && randomnum <= 10) {
		UFO_Init();
	}
}

// **************Bunker_Init*********************
// Initialize the bunker which is used to shield the player's
// ship from enemy fire.
// Input: none
// Output: none
void Bunker_Init(void){
	Bunker.x = 33;			// positions the bunker in the middle of the screen
	Bunker.y = 47 - PLAYERH;	// positions the bunker just above the max y point of the player
	Bunker.maxpoint[0] = Bunker.x + BUNKERW;
	Bunker.maxpoint[1] = Bunker.y + BUNKERH;
	Bunker.image[0] = Bunker0;	// no damage
	Bunker.image[1] = Bunker1;	// slight damage
	Bunker.image[2] = Bunker2;	// medium damage
	Bunker.image[3] = Bunker3;	// destroyed
	Bunker.life = 10;
}

// **************Player_Init*********************
// Initialize enemy ship in the middle/bottom of the screen (Nokia 5110 width = 84 pixels,
// height = 48 pixels).
// Input: none
// Output: none
void Player_Init(void){
	Player.x = 32;	
	Player.y = 47;		
	Player.maxpoint[0] = Player.x + PLAYERW;
	Player.maxpoint[1] = Player.y + PLAYERH;
	Player.image[0] = PlayerShip0;		// no damage
	Player.image[1] = BigExplosion0;	// destroyed
	Player.life = 20;
	Player.deathCounter = 3;			// counts down time to display explosion before displaying Game Over message
}

// **************Player_Move*********************
// Update player x-position using ADC0 input from slider.
// Input: x-coordinate ranging from 0-66 (84 pixels - PLAYERW = 66 pixels).
// Output: none
void Player_Move(unsigned int position){
	Player.x = position;
	Player.maxpoint[0] = Player.x + PLAYERW;
}

// **************Player_Missile_Init*********************
// Initialize the player's missile.  Players can only launch 
// one missile at a time.
// Input: none
// Output: none
void Player_Missile_Init(void){
	Missile[playMissile].x = Player.x + (PLAYERW/2);  
	Missile[playMissile].y = Player.y - 4;		// initialize the missile 4 pixels above the ship
	Missile[playMissile].maxpoint[0] = Missile[playMissile].x + MISSILEW;
	Missile[playMissile].maxpoint[1] = Missile[playMissile].y + MISSILEH;
	Missile[playMissile].image[0] = Missile0;		// full health
	Missile[playMissile].image[1] = Missile2;		// no health (image is blank space)
  Missile[playMissile].life = 1;
	Missile[playMissile].deathCounter = 3;
	GPIO_PORTE_DATA_R |= 0x10;				// turn on missile active light
}

// **************Enemy_Missile_Init*********************
// Uses randomnum to randomize the initialization of enemy missiles.
// Only enemies with no other enemies below can launch missiles.
// Input: none
// Output: none
void Enemy_Missile_Init(void) {
	int i;
	for(i=0;i<numEnemies;i++) {
		if((Enemy[i].life > 0) && (Missile[i].life <= 0) && ((i+2) == randomnum)) {
			if((i >= 4) || (Enemy[i%4].life <= 0)) {		// if no other enemies directly below
				Missile[i].x = Enemy[i].x + (ENEMY30W/2);
				Missile[i].y = Enemy[i].y + 4;		// initialize the missile 4 pixels below the enemy
				Missile[i].maxpoint[0] = Missile[i].x + MISSILEW;
				Missile[i].maxpoint[1] = Missile[i].y + MISSILEH;
				Missile[i].image[0] = Missile0;		// full health
				Missile[i].image[1] = Missile2;		// no health (image is blank space)
				Missile[i].life = 1;
				Missile[i].deathCounter = 3;		// counts down time to display small explosion
			}
		}
	}
}

// **************Missile_Move*********************
// Move the player missile up the screen if it's health is not zero.
// If the y-coordinate of the missile exceeds the maximum y-coordinate 
// of the screen, reduce the missile's life to zero.
// Input: none
// Output: none
void Missile_Move(void) {
	if((Missile[playMissile].life == 1) && (Missile[playMissile].y <= 48)){
		Missile[playMissile].y -= 3; // move up
		Missile[playMissile].maxpoint[1] -= 3;
	} else {
		Missile[playMissile].life = 0;		// delete the missile if it moves off screen
		GPIO_PORTE_DATA_R &= ~(0x10);				// turn off missile active light
	}
}

// **************Enemy_Missile_Move*********************
// Move the enemy missile up the screen if it's health is not zero.
// If the y-coordinate of the missile exceeds the maximum y-coordinate 
// of the screen, reduce the missile's life to zero.
// Input: none
// Output: none
void Enemy_Missile_Move(void) {
	int i;
	for(i=0;i<numEnemies;i++) {
		if((Missile[i].life == 1) && (Missile[i].y <= 48)) {
			Missile[i].y += 3;	// move down
			Missile[i].maxpoint[1] += 3;	// move down
		} else {
		Missile[i].life = 0;		// delete the missile if it moves off screen
		}
	}
}

// **************Player_Laser_Init*********************
// Initialize the player's laser.  Players can only launch 
// one laser at a time.
// Input: none
// Output: none
void Player_Laser_Init(void){
	Laser[playLaser].x = Player.x + (PLAYERW/2);
	Laser[playLaser].y = Player.y - 4;		// initialize the laser 4 pixels above the ship
	Laser[playLaser].maxpoint[0] = Laser[playLaser].x + LASERW;
	Laser[playLaser].maxpoint[1] = Laser[playLaser].y + LASERH;
	Laser[playLaser].image[0] = Laser0;			// full health
	Laser[playLaser].image[1] = Laser1;			// no health (image is blank space)
  Laser[playLaser].life = 1;
	Laser[playLaser].deathCounter = 3;
	Sound_Shoot();
	GPIO_PORTE_DATA_R |= 0x20;				// turn on laser active light
}

// **************Enemy_Laser_Init*********************
// Uses randomnum to randomize the initialization of enemy lasers.
// Only enemies with no other enemies below can launch lasers.
// Input: none
// Output: none
void Enemy_Laser_Init(void) {
	int i;
	for(i=0;i<numEnemies;i++) {
		if((Enemy[i].life > 0) && (Laser[i].life <= 0) && ((i+3) == randomnum)) { 
			if((i >= 4) || (Enemy[i%4].life <= 0)) {
				Laser[i].x = Enemy[i].x + (ENEMY30W/2);
				Laser[i].y = Enemy[i].y + 4;
				Laser[i].maxpoint[0] = Laser[i].x + LASERW;
				Laser[i].maxpoint[1] = Laser[i].y + LASERH;
				Laser[i].image[0] = Laser0;			// full health
				Laser[i].image[1] = Laser1;			// no health (image is blank space)
				Laser[i].life = 1;
				Laser[i].deathCounter = 3;			// counts down time to display small explosion
			}
		}
	}
}

// **************Laser_Move*********************
// Move the player laser up the screen if it's health is not zero.
// If the y-coordinate of the laser exceeds the maximum y-coordinate 
// of the screen, reduce the laser's life to zero.
// Input: none
// Output: none
void Laser_Move(void) {
	if((Laser[playLaser].life == 1) && (Laser[playLaser].y <= 48)){
		Laser[playLaser].y -= 4; // move up
		Laser[playLaser].maxpoint[1] -= 4; // move up
	} else {
		Laser[playLaser].life = 0;		// delete the laser if it moves off screen
		GPIO_PORTE_DATA_R &= ~(0x20);				// turn off laser active light
	}
}

// **************Enemy_Laser_Move*********************
// Move the enemy laser up the screen if it's health is not zero.
// If the y-coordinate of the laser exceeds the maximum y-coordinate 
// of the screen, reduce the laser's life to zero.
// Input: none
// Output: none
void Enemy_Laser_Move(void) {
	int i;
	for(i=0;i<numEnemies;i++) {
		if((Laser[i].life == 1) && (Laser[i].y <= 48)) {
			Laser[i].y += 4;		// move down
			Laser[i].maxpoint[1] += 4;		// move down
		} else {
			Laser[i].life = 0;		// delete the laser if it moves off screen
		}
	}
}

// **************Check_Damage*********************
// Checks whether a missile or laser has collided with an object.
// If there is a colission, reduce the life of both the missile/laser
// and the object.
// Input: none
// Output: none
void Check_Damage(void){
	int i, j;
	// check whether a missile/laser has collided with the bunker
	for(j=0;j<numEnemies;j++){
		if((Missile[j].life == 1) && (Bunker.life > 0) && ((Bunker.x-2) <= Missile[j].x) && (Missile[j].x <= (Bunker.maxpoint[0]+2)) 
				&& ((Bunker.y+10) <= Missile[j].maxpoint[1])){
      Bunker.life -= 2;
			Missile[j].life = 0;		// delete the missile
		}
		if((Laser[j].life == 1) && (Bunker.life > 0) && ((Bunker.x-2) <= Laser[j].x) && (Laser[j].x <= (Bunker.maxpoint[0]+2)) 
				&& ((Bunker.y+10) <= Laser[j].maxpoint[1])){
			Bunker.life -= 1;				
			Laser[j].life = 0;		// delete the laser
		}
	}
	if((Missile[playMissile].life == 1) && (Bunker.life > 0) && ((Bunker.x-2) <= Missile[playMissile].x) && (Missile[playMissile].x <= (Bunker.maxpoint[0]+2))) {
    Bunker.life -= 2;
		Missile[playMissile].life = 0;		// delete the missile
		GPIO_PORTE_DATA_R &= ~(0x10);				// turn off missile active light
	}
	if((Laser[playMissile].life == 1) && (Bunker.life > 0) && ((Bunker.x-2) <= Laser[playLaser].x) && (Laser[playLaser].x <= (Bunker.maxpoint[0]+2))) {
		Bunker.life -= 1;				
		Laser[playLaser].life = 0;		// delete the laser
		GPIO_PORTE_DATA_R &= ~(0x20);				// turn off laser active light
	}
	// check whether an enemy missile/laser has collided with the player
	for(j=0;j<numEnemies;j++) {
		if((Missile[j].life == 1) && (Player.x <= Missile[j].x) && (Missile[j].x <= Player.maxpoint[0]) 
				&& (Player.y <= Missile[j].y) && (Missile[j].y <= Player.maxpoint[1])){
			Player.life -= 2;
			Missile[j].life = 0;		// delete the missile
		}
		if((Laser[j].life == 1) && (Player.x <= Laser[j].x) && (Laser[j].x <= Player.maxpoint[0]) && (Player.y <= Laser[j].y)
				&& (Laser[j].y <= Player.maxpoint[1])){
			Player.life -= 1;
			Laser[j].life = 0;		// delete the laser
		}
	}
	// check whether a player missile has collided with an enemy
	for(i=0;i<numEnemies;i++) {
		if((Missile[playMissile].life == 1) && (Enemy[i].life > 0) && (Enemy[i].x <= Missile[playMissile].x) && (Missile[playMissile].x <= Enemy[i].maxpoint[0])
				&& (Enemy[i].y <= Missile[playMissile].y) && (Missile[playMissile].y <= Enemy[i].maxpoint[1])){
			Enemy[i].life -= 2;
			Missile[playMissile].life = 0;		// delete the missile
			GPIO_PORTE_DATA_R &= ~(0x10);				// turn off missile active light
			Sound_Killed();
		}
		
		if((Laser[playLaser].life == 1) && (Enemy[i].life > 0) && (Enemy[i].x <= Laser[playLaser].x) && (Laser[playLaser].x <= Enemy[i].maxpoint[0]) 
				&& (Enemy[i].y <= Laser[playLaser].y) && (Laser[playLaser].y <= Enemy[i].maxpoint[1])){
			Enemy[i].life -= 1;
			Laser[playLaser].life = 0;		// delete the laser
			GPIO_PORTE_DATA_R &= ~(0x20);				// turn off laser active light
			Sound_Killed();
		}
		// if the enemy has no life left display explosion image
		if(Enemy[i].life <= 0) {
			Enemy[i].image[0] = SmallExplosion0;
			Enemy[i].image[1] = SmallExplosion1;
			if(Enemy[i].deathCounter > 0) {
				Enemy[i].deathCounter -= 1;
			}
		} 
	}
	// check whether a player missile/laser has collided with an enemy missile/laser
	for(i=0;i<numEnemies;i++) {
		if((Missile[playMissile].life == 1) && (Missile[i].x <= Missile[playMissile].x) && (Missile[playMissile].x <= Missile[i].maxpoint[0]) 	
				&& (Missile[i].y <= Missile[playMissile].y) && (Missile[playMissile].y <= Missile[i].maxpoint[1])){
			Missile[i].life = 0;								// delete enemy missile
			Missile[playMissile].life = 0;			// delete player missile
			GPIO_PORTE_DATA_R &= ~(0x10);				// turn off missile active light
		}
		
		if((Laser[playLaser].life == 1) && (Laser[i].x <= Laser[playLaser].x) && (Laser[playLaser].x <= Laser[i].maxpoint[0]) 
				&& (Laser[i].y <= Laser[playLaser].y) && (Laser[playLaser].y <= Laser[i].maxpoint[1])){
			Laser[i].life = 0;						// delete enemy laser
			Laser[playLaser].life = 0;		// delete player laser
			GPIO_PORTE_DATA_R &= ~(0x20);				// turn off laser active light
		}
	}
	// if the player has no life left display big explosion image
	if(Player.life <= 0) {
		Player.image[0] = BigExplosion0;
		Player.image[1] = BigExplosion1;
		if(Player.deathCounter > 0) {
			Player.deathCounter -= 1;
		}
	}
	
	// check whether a player missile has collided with the UFO
	if((Missile[playMissile].life == 1) && (UFO.life > 0) && (UFO.x <= Missile[playMissile].x) && (Missile[playMissile].x <= UFO.maxpoint[0])
			&& (UFO.y <= Missile[playMissile].y) && (Missile[playMissile].y <= UFO.maxpoint[1])){
		UFO.life -= 2;
		Missile[playMissile].life = 0;		// delete the missile
		GPIO_PORTE_DATA_R &= ~(0x10);				// turn off missile active light
		Sound_Killed();
	}
		
	if((Laser[playLaser].life == 1) && (UFO.life > 0) && (UFO.x <= Laser[playLaser].x) && (Laser[playLaser].x <= UFO.maxpoint[0])
			&& (UFO.y <= Laser[playLaser].y) && (Laser[playLaser].y <= UFO.maxpoint[1])){
		UFO.life -= 1;
		Laser[playLaser].life = 0;		// delete the laser
		GPIO_PORTE_DATA_R &= ~(0x20);				// turn off laser active light
		Sound_Killed();
	}
			
	if(UFO.life <= 0) {
			UFO.image[0] = SmallExplosion0;
			UFO.image[1] = SmallExplosion1;
			if(UFO.deathCounter > 0) {
				UFO.deathCounter -= 1;
			}
		}
}

// **************Draw*********************
// Writes images to buffer if object has been initialized.
// Input: none
// Output: none
void Draw(void){ int i;
  Nokia5110_ClearBuffer();
	Check_Damage();			// check if any objects have been damaged or destroyed
  for(i=0;i<numEnemies;i++){
    if(Enemy[i].life > 0){
      Nokia5110_PrintBMP(Enemy[i].x, Enemy[i].y, Enemy[i].image[FrameCount], 0);	// animate the enemies using 2 frames
    } else if (Enemy[i].deathCounter > 0) {
		  Nokia5110_PrintBMP(Enemy[i].x, Enemy[i].y, Enemy[i].image[0], 0);		// draw small explosion image
		} else {
			Nokia5110_PrintBMP(Enemy[i].x, Enemy[i].y, Enemy[i].image[1], 0);		// draw blank space
		}
  }
	
	if(Bunker.life >= 7) {
		Nokia5110_PrintBMP(Bunker.x, Bunker.y, Bunker.image[0], 0);		// draw full health bunker
	} else if(Bunker.life < 7 && Bunker.life >= 4) {
		Nokia5110_PrintBMP(Bunker.x, Bunker.y, Bunker.image[1], 0);		// draw slightly damaged bunker
	} else if(Bunker.life < 4 && Bunker.life >= 1) {
		Nokia5110_PrintBMP(Bunker.x, Bunker.y, Bunker.image[2], 0);		// draw moderately damaged bunker
	} else if(Bunker.life <= 0) {
		Nokia5110_PrintBMP(Bunker.x, Bunker.y, Bunker.image[3], 0);		// draw blank space
	}
	
	if(Player.life > 0){
      Nokia5110_PrintBMP(Player.x, Player.y, Player.image[0], 0);		// draw full health player
    } else if (Player.deathCounter > 0) {
		  Nokia5110_PrintBMP(Player.x, Player.y, Player.image[0], 0);		// draw big explosion
		} else {
			Nokia5110_PrintBMP(Player.x, Player.y, Player.image[1], 0);		// draw blank space
		}
		
	if(UFO.life > 0){
      Nokia5110_PrintBMP(UFO.x, UFO.y, UFO.image[0], 0);		// draw full health UFO
    } else if (UFO.deathCounter > 0) {
		  Nokia5110_PrintBMP(UFO.x, UFO.y, UFO.image[0], 0);		// draw small explosion
		} else {
			Nokia5110_PrintBMP(UFO.x, UFO.y, UFO.image[1], 0);		// draw blank space
		}
	
	for(i=0;i<(numEnemies+1);i++) {
		if(Missile[i].life == 1) {
			Nokia5110_PrintBMP(Missile[i].x, Missile[i].y, Missile[i].image[0], 0);		// draw missile
		}
		
		if(Laser[i].life == 1) {
			Nokia5110_PrintBMP(Laser[i].x, Laser[i].y, Laser[i].image[0], 0);		// draw laser
		} 
	}
	
  Nokia5110_DisplayBuffer();      // draw buffer
	FrameCount = (FrameCount+1)&0x01; // 0,1,0,1,...
}

// **************Delay100ms*********************
// Input: none
// Output: none
void Delay100ms(unsigned long count){unsigned long volatile time;
  while(count>0){
    time = 727240;  // 0.1sec at 80 MHz
    while(time){
	  	time--;
    }
    count--;
  }
}

// **************Delay1ms*********************
// Input: none
// Output: none
void Delay1ms(unsigned long msec){
	unsigned long i;
  while(msec > 0){
    i = 13333;  // approximately 1 ms at 80 MHz (1ms/12.5ns/6)
    while(i > 0){
      i = i - 1;
    }
    msec = msec - 1;
  }
}

//------------Game_Over------------
// Clear the Nokia screen and display the "Game Over" message when the player dies
// Input: none
// Output: none
void Game_Over(void) {
	Delay100ms(2);              // delay 200 msec at 50 MHz
  Nokia5110_Clear();
  Nokia5110_SetCursor(1, 1);
  Nokia5110_OutString("GAME OVER");
  Nokia5110_SetCursor(1, 2);
  Nokia5110_OutString("Nice try,");
  Nokia5110_SetCursor(1, 3);
  Nokia5110_OutString("Earthling!");
  while(1){
  }
}

// **************Level_Check*********************
// If all enemies have been eliminated, display Next Level message.
// Input: none
// Output: none
void Level_Check(void){  
	int i;
	int enemiesDead = 0;
	if(Player.life <= 0 && Player.deathCounter <= 0) {
		Game_Over();		// display game over message
	}
	// check the number of enemies destroyed
	for(i=0;i<numEnemies;i++) {		
		if(Enemy[i].life <= 0) {
			enemiesDead += 1;
		}
		// if enemies reach bottom of screen, game over
		if((Enemy[i].maxpoint[1] >= Player.y) && (Enemy[i].life > 0)) {
			Game_Over();
		}
	}
	// if all enemies destroyed, move to next level
	if(enemiesDead == numEnemies) {
		currentLevel += 1;
		enemyDir = currentLevel;
		Delay100ms(2);              // delay 200 msec at 50 MHz
		Nokia5110_Clear();
		Nokia5110_SetCursor(1, 2);
		Nokia5110_OutString("LEVEL");
		Nokia5110_SetCursor(1, 6);
		Nokia5110_OutUDec(currentLevel);
		Delay100ms(5);              // delay 500 msec at 50 MHz
		Enemy_Init();				// reset enemies
		Bunker_Init();			// reset bunker
		Player_Init();			// reset player
	}
}

// **************Systick_Init*********************
// Initialize Systick periodic interrupts
// Also calls DAC_Init() to initialize DAC
// Input: none
// Output: none
// reload value of 2666666 = 30 Hz
void Systick_Init(void){
	NVIC_ST_CTRL_R = 0;         // disable SysTick during setup
  NVIC_ST_RELOAD_R = 2666;// reload value
  NVIC_ST_CURRENT_R = 0;      // any write to current clears it
  NVIC_SYS_PRI3_R = NVIC_SYS_PRI3_R&0x00FFFFFF; // priority 0
  NVIC_ST_CTRL_R = 0x0007; // enable,core clock, and interrupts
}

//------------ADC0_Init------------
// This initialization function sets up the ADC 
// Max sample rate: <=125,000 samples/second
// SS3 triggering event: software trigger
// SS3 1st sample source:  channel 1
// SS3 interrupts: enabled but not promoted to controller
void ADC0_Init(void){ 
	unsigned long delay;
  SYSCTL_RCGC2_R |= 0x00000010;   // 1) activate clock for Port E
  delay = SYSCTL_RCGC2_R;         //    allow time for clock to stabilize
  GPIO_PORTE_DIR_R &= ~0x04;      // 2) make PE2 input
  GPIO_PORTE_AFSEL_R |= 0x04;     // 3) enable alternate function on PE2
  GPIO_PORTE_DEN_R &= ~0x04;      // 4) disable digital I/O on PE2
  GPIO_PORTE_AMSEL_R |= 0x04;     // 5) enable analog function on PE2
  SYSCTL_RCGC0_R |= 0x00010000;   // 6) activate ADC0
  delay = SYSCTL_RCGC2_R;        
  SYSCTL_RCGC0_R &= ~0x00000300;  // 7) configure for 125K
  ADC0_SSPRI_R = 0x0123;          // 8) Sequencer 3 is highest priority
  ADC0_ACTSS_R &= ~0x0008;        // 9) disable sample sequencer 3
  ADC0_EMUX_R &= ~0xF000;         // 10) seq3 is software trigger
  ADC0_SSMUX3_R &= ~0x000F;       // 11) clear SS3 field
  ADC0_SSMUX3_R += 1;             //    set channel Ain1 (PE2)
  ADC0_SSCTL3_R = 0x0006;         // 12) no TS0 D0, yes IE0 END0
  ADC0_ACTSS_R |= 0x0008;         // 13) enable sample sequencer 3
}

//------------ADC0_In------------
// Busy-wait Analog to digital conversion
// Input: none
// Output: 12-bit result of ADC conversion
unsigned long ADC0_In(void){  
	unsigned long result;
  ADC0_PSSI_R = 0x0008;            // 1) initiate SS3
  while((ADC0_RIS_R&0x08)==0){};   // 2) wait for conversion done
  result = ADC0_SSFIFO3_R&0xFFF;   // 3) read result
  ADC0_ISC_R = 0x0008;             // 4) acknowledge completion
  return result;
}

//------------Switch_Init------------
// Initialize the two switches used to launch missles on PE1 and PE0
// Input: none
// Output: none
void Switch_Init(void){ 
	unsigned long delay;
  SYSCTL_RCGC2_R |= 0x00000010;   // 1) activate clock for Port E
  delay = SYSCTL_RCGC2_R;         //    allow time for clock to stabilize
	GPIO_PORTE_PCTL_R &= ~0x000000FF; // 2) regular GPIO function
  GPIO_PORTE_DIR_R &= ~0x03;      // 3) make PE1-PE0 input
  GPIO_PORTE_AFSEL_R &= ~0x03;     // 4) disable alternate function on PE1-PE0
  GPIO_PORTE_DEN_R |= 0x03;      // 5) enable digital I/O on PE1-PE0
  GPIO_PORTE_AMSEL_R &= ~0x03;     // 6) disable analog function on PE1-PE0
	GPIO_PORTE_IS_R &= ~0x03;     // 7) PE1-PE0 is edge-sensitive
  GPIO_PORTE_IBE_R &= ~0x03;    // 8)  PE1-PE0 is not both edges
  GPIO_PORTE_IEV_R |= 0x03;    // 9)  PE1-PE0 rising edge event
  GPIO_PORTE_ICR_R = 0x03;      // 10) clear flags 1,0
  GPIO_PORTE_IM_R |= 0x03;      // 11) arm interrupt on PE1-PE0
  NVIC_PRI1_R = (NVIC_PRI1_R&0xFFFFFF0F)|0x40; // 12) priority 2
  NVIC_EN0_R = 0x10;      // 13) enable interrupt 4 in NVIC
}

//------------LED_Init------------
// Initialize the two LEDs on on PB5 and PB4
// Input: none
// Output: none
void LED_Init(void){ 
	unsigned long delay;
	SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOB; // activate port B
  delay = SYSCTL_RCGC2_R;    // allow time to finish activating
  delay = SYSCTL_RCGC2_R;         //    allow time for clock to stabilize
	GPIO_PORTB_PCTL_R &= ~0x00FF0000; // 2) regular GPIO function
  GPIO_PORTE_DIR_R |= 0x30;      // 3) make PB5-PB4 output
  GPIO_PORTE_AFSEL_R &= ~0x30;     // 4) disable alternate function on PB5-PB4
  GPIO_PORTE_DEN_R |= 0x30;      // 5) enable digital I/O on PB5-PB4
  GPIO_PORTE_AMSEL_R &= ~0x30;     // 6) disable analog function on PB5-PB4
	GPIO_PORTE_DATA_R &= ~0X30;			//7) clear the data register for PB5-PB4
}

//********Convert****************
// Convert a 12-bit binary ADC sample into a number from 0 to 66.  
// Calibration data is gathered using number of pixels of width of the Nokia5110
// and reading the ADC value measured on PE1. The width of the Nokia5110 is 84 pixels
// and the width of the player ship BMP image is 18 pixels.
// Overflow and dropout should be considered 
// Input: sample  12-bit ADC sample
// Output: integer between 0 and 66
unsigned int Convert(unsigned long sample){
  return (66*sample)/4095;
}

void SysTick_Handler(void){  // runs at 30 Hz
	int i;
	ADCdata = ADC0_In();
	playerPosition = Convert(ADCdata);
  playerFlag = 1;
}

void GPIOPortE_Handler(void){
  GPIO_PORTE_ICR_R = 0x03; // ack, clear interrupt flag 1,0
  if(GPIO_PORTE_DATA_R == 0x01 && Missile[playMissile].life <= 0) {
			missileFlag = 1;
			randomnum += 3;
			GPIO_PORTE_DATA_R = 0;
		} else if(GPIO_PORTE_DATA_R == 0x02 && Laser[playLaser].life <= 0) {
			laserFlag = 1;
			randomnum += 5;
			GPIO_PORTE_DATA_R = 0;
		} else if(Missile[playMissile].life <= 0) {
			missileFlag = 1;
			randomnum += 7;
			GPIO_PORTE_DATA_R = 0;
		} else if(Laser[playLaser].life <= 0) {
			laserFlag = 1;
			randomnum += 9;
			GPIO_PORTE_DATA_R = 0;
		}
}

int main(void){
  TExaS_Init(SSI0_Real_Nokia5110_Scope);  // set system clock to 80 MHz
	Systick_Init();
	ADC0_Init();
	LED_Init();
	Switch_Init();
  Nokia5110_Init();
	Random_Init(1);
	Sound_Init();
	
  Nokia5110_ClearBuffer();
	Nokia5110_DisplayBuffer();      // draw buffer
	currentLevel = 1;
	Enemy_Init();
	Bunker_Init();
  Player_Init();
  Draw();

  while(1){;
		randomnum = (Random32()>>24)%60; // a number from 0 to 59
		Enemy_Missile_Init();
		Enemy_Laser_Init();
		Enemy_Missile_Move();
		Enemy_Laser_Move();
		Level_Check();

		if(playerFlag == 1) {
			Player_Move(playerPosition);
			playerFlag = 0;
		}
		if(missileFlag == 1) {
			Player_Missile_Init();
			missileFlag = 0;
		}
		if(laserFlag == 1) {
			Player_Laser_Init();
			laserFlag = 0;
		}
		if(Missile[playMissile].life > 0) {
			Missile_Move();
		}
		if(Laser[playLaser].life > 0) {
			Laser_Move();
		}
		
		Enemy_Move();
		UFO_Move();
    Draw();
		Delay1ms(25); //for simulation
		//Delay1ms(300);	// for real board
  }
}
